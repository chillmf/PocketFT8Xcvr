/**
 * AGUI isolates the widget implementations from the various Adafruit GFX library variations. 
 * There's some minor added functionality but it's mostly an adapter to glue widgets to GFX. 
 *  + Display types (e.g. TFT, etc)
 *  + Display controllers (e.g. HX8357, etc)
 *  + Display size (e.g. 480x320, etc)
 *  + Hardware interfaces (e.g. parallel, SPI)
 *  + MCU customization (e.g. Teensy)
 *  + Font support (GFX, ILI9341, Adafruit 5x7, etc)
 * While the isolation is not complete (fonts are a notable weakness), the task of switching
 * Adafruit libraries is largely confined to changes in just this class.
 *
 * IMPLEMENTATION
 * The original implementation of AGUI was for a 480x320 TFT display using the
 * HX8357D controller attached to a Teensy 4.1 through an SPI bus.  The AGUI code was
 * developed using Visual Studio Code, PlatformIO and many Arduino library dependencies.
 *
 * DESIGN NOTES
 *  + AGUI is heavily dependent upon the Arduino environment including the data types,
 *    classes (e.g. bool and String) and functions defined in Arduino.h
 *  + This is a minimalist approach with an Adafruit accent for a GUI library.  Consider
 *    LGVL for a more full-featured solution.
 *  + This driver should probably become a singleton if multiple displays are forbidden
 *  + There is no dependency on nor interaction with the touchscreen system here.  See
 *    AWidget's static processTouch() method. 
 *  + Not every GFX method is adapted here.
 *
 * DEPENDENCIES
 *  + https://github.com/adafruit/Adafruit_HX8357_Library
 *                          or
 *  + https://github.com/mjs513/HX8357_t3n
 *                          and
 *  + https://github.com/adafruit/Adafruit-GFX-Library
 *
 * REFERENCES
 * While on-line tutorials are available for the Adafruit GFX library, I've found minimal
 * complete documentation of the APIs and nothing but the source code for many versions on
 * github.  As of March, 2025, this is the best almost-complete API description I've found:
 * https://adafruit.github.io/Adafruit-GFX-Library/html/class_adafruit___g_f_x.html
 * If the API you seek isn't in there, you'll have to resort to the your library's source.
 **/

#include "AGUI.h"

#include <SPI.h>

#include "Adafruit_GFX.h"  //HX8357_t3n requires you #include GFX before...
//#include "Fonts/FreeSans9pt7b.h"
#include "HX8357_t3n.h"  //you #include the HX8357 variation.
#include "NODEBUG.h"     //For printf-style debugging on a Teensy sans JTAG :(
//#include "ft8_font.h"    //Include a default font

//-----------------------------------------------------------------------------

HX8357_t3n* AGUI::gfx;
const GFXfont* AGUI::appFont;  // Default font for this application

//-----------------------------------------------------------------------------
//  Initialization
//-----------------------------------------------------------------------------

/**
 * @brief Construct the AGUI object
 * @param tft Pointer to an Adafruit display driver (e.g. HX8357_t3n) object
 * @param rotation GFX screen rotation parameter
 * @param font Pointer to a default GFX font structure
 */
AGUI::AGUI(HX8357_t3n* tft, uint8_t rotation, const GFXfont* font) {
    if (!Serial) Serial.begin(9600);
    Serial.print("AGUI()=");

    // Record configuration params
    gfx = tft;                  // Adafruit display object
    appFont = font;             // Application's default font
    screenRotation = rotation;  // See Adafruit HX8357 doc for values

    // Setup the Adafruit display and graphics library for use by our application
    gfx->begin(30000000UL, 2000000UL);  // Configure SPI clock speeds
    gfx->setRotation(rotation);         // Configure screen rotation
    gfx->setFont(appFont);              // Configure the font
    gfx->fillScreen(HX8357_BLACK);      // Erase the display

    //Serial.println("Exit AGUI\n");
}



//-----------------------------------------------------------------------------
//  Graphical methods
//-----------------------------------------------------------------------------

/**
 * @brief Define the display's clip window rectangle
 * @param clipX x-Screen coordinate
 * @param clipY y-Screen coordinate
 * @param clipW width in pixels
 * @param clipH height in pixels
 *
 * @note GFX supports a single clip window
 */
void AGUI::setClipRect(ACoord clipX, ACoord clipY, ACoord clipW, ACoord clipH) {
    DPRINTF("setClipRect(%d,%d,%d,%d)\n", clipX, clipY, clipW, clipH);
    gfx->setClipRect(clipX, clipY, clipW, clipH);
}

/**
 * @brief Set the clip window to the full-screen
 */
void AGUI::setClipRect(void) {
    gfx->setClipRect();
}

/**
 * @brief Draw a single pixel of specified color
 * @param x Coordinate
 * @param y Coordinate
 * @param color Specified color
 */
void AGUI::drawPixel(int16_t x, int16_t y, AColor color) {
    gfx->drawPixel(x, y, color);
}

/**
 * @brief Fill a rectangle on the screen with the specified color
 * @param xCoord upper-left corner of rectangle
 * @param yCoord upper-left corner of rectangle
 * @param w width of rectangle
 * @param h height of rectangle
 * @param color Specified color
 */
void AGUI::fillRect(ACoord xCoord, ACoord yCoord, ACoord w, ACoord h, AColor color) {
    DTRACE();
    gfx->fillRect(xCoord, yCoord, w, h, color);
    DTRACE();
}

/**
 * @brief Draws a filled, rounded rectangle on the screen with the specified color
 * @param xCoord Upper-left corner of rectangle
 * @param yCoord Upper-left corner of rectangle
 * @param w Width of rectangle
 * @param h Height of rectangle
 * @param r Radius of the rounded corners
 * @param color Fill color
 */
void AGUI::fillRoundRect(ACoord xCoord, ACoord yCoord, ACoord w, ACoord h, ACoord r,
                         AColor color) {
    gfx->fillRoundRect(xCoord, yCoord, w, h, r, color);
}

/**
 * @brief Draw outline of a rectangle on the screen with the specified color
 * @param xCoord upper-left corner of rectangle
 * @param yCoord upper-left corner of rectangle
 * @param w width of rectangle
 * @param h height of rectangle
 * @param color Specified color
 */
void AGUI::drawRect(ACoord xCoord, ACoord yCoord, ACoord w, ACoord h, AColor color) {
    gfx->drawRect(xCoord, yCoord, w, h, color);
}

/**
 * @brief Draw border of a rounded rectangle on the screen with the specified color
 * @param xCoord Upper-left corner of rectangle
 * @param yCoord Upper-left corner of rectangle
 * @param w Width
 * @param h Height
 * @param r Radius of the rounded corners
 * @param color Border color
 */
void AGUI::drawRoundRect(ACoord xCoord, ACoord yCoord, ACoord w, ACoord h, ACoord r,
                         AColor color) {
    gfx->drawRoundRect(xCoord, yCoord, w, h, r, color);
}

//-----------------------------------------------------------------------------
//  Text methods
//-----------------------------------------------------------------------------

/**
 * @brief Select the specified GFX font
 * @param f Pointer to the GFXfont struct
 */
void AGUI::setFont(const GFXfont* f) {
    gfx->setFont(f);
}

/**
 * @brief Select the specified GFX font
 * @param f Pointer to the GFXfont struct
 */
void AGUI::setFont(void) {
    gfx->setFont();
}

/**
 * @brief Select the specified ILI9341 font
 * @param f Pointer to an ILI9341_t3_font struct
 */
void AGUI::setFont(const ILI9341_t3_font_t& f) {
    gfx->setFont(f);
}

/**
 * @brief Get the leading for the selected font
 * @return Number of pixels between lines
 *
 * @note "Leading" refers to the number of pixels between lines including the height
 * of the text and the white space between lines
 *
 * @note You may have to modify or subclass the GFX library to implement this because
 * the required font metrics for the calculation are protected in Adafruit_GFX.   If
 * you *really* don't want to do this, you could just cast-it-in-brass here if you're
 * only using a single font.
 */
ACoord AGUI::getLeading() {
    DTRACE();
    return gfx->getLeading();
}

/**
 * @brief Place the text cursor at the specified coordinate
 * @param xCoord coordinate
 * @param yCoord coordinate
 */
void AGUI::setCursor(ACoord xCoord, ACoord yCoord) {
    gfx->setCursor(xCoord, yCoord);
}

/**
 * @brief Set the text foreground color
 * @param fg Specified color
 *
 * @note Subsequent text will be displayed in the specified color
 */
void AGUI::setTextColor(AColor fg) {
    gfx->setTextColor(fg);
}

/**
 * @brief Set the text foreground and background colors
 * @param fg Foreground color
 * @param bg Background color
 *
 * @note Subsequent text will be displayed in the specified colors
 */
void AGUI::setTextColor(AColor fg, AColor bg) {
    gfx->setTextColor(fg, bg);
}

/**
 * @brief Specify whether text should wrap
 * @param w true==>wrap, false if not
 */
void AGUI::setTextWrap(bool w) {
    gfx->setTextWrap(w);
}

/**
 * @brief Writes size chars from buffer to the display
 * @param buffer Characters to write
 * @param size #chars to write
 * @return #chars actually written
 *
 * We seem to be writing 7-bit ASCII chars, written left-to-write, starting
 * at the current cursor position.
 */
size_t AGUI::writeText(const uint8_t* buffer, size_t size) {
    return gfx->write(buffer, size);
}

/**
 * @brief Write Arduino String to the display
 * @param str The String to write
 * @return #chars actually written
 */
size_t AGUI::writeText(String str) {
    return gfx->write((const uint8_t*)str.c_str(), str.length());
}

/**
 * @brief Get the boundary rectangle for the specified character string buffer
 * @param buffer The characters
 * @param len #chars in buffer
 * @param x Specify the upper-left coordinate of the boundary rectangle
 * @param y Specify the upper-left coordinate of the boundary rectangle
 * @param x1 Calculated lower-right coordinate of the boundary rectangle
 * @param y1 Calculated lower-right coordinate of the boundary rectangle
 * @param w Calculated width of the boundary rectangle
 * @param h Calculated height of the boundary rectangle
 */
void AGUI::getTextBounds(const uint8_t* buffer, uint16_t len, ACoord x, ACoord y,
                         ACoord* x1, ACoord* y1, ACoord* w, ACoord* h) {
    gfx->getTextBounds(buffer, len, (int16_t)x, (int16_t)y, (int16_t*)x1, (int16_t*)y1, (uint16_t*)w, (uint16_t*)h);
}

/**
 * @brief Get the boundary rectangle for the specified character string
 * @param string NUL-terminated char[] string
 * @param x Specify the upper-left coordinate of the boundary rectangle
 * @param y Specify the upper-left coordinate of the boundary rectangle
 * @param x1 Calculated lower-right coordinate of the boundary rectangle
 * @param y1 Calculated lower-right coordinate of the boundary rectangle
 * @param w Calculated width of the boundary rectangle
 * @param h Calculated height of the boundary rectangle
 */
void AGUI::getTextBounds(const char* string, ACoord x, ACoord y,
                         ACoord* x1, ACoord* y1, ACoord* w, ACoord* h) {
    gfx->getTextBounds(string, (int16_t)x, (int16_t)y, (int16_t*)x1, (int16_t*)y1, (uint16_t*)w, (uint16_t*)h);
}

/**
 * @brief Get the boundary rectangle for the specified String
 * @param str String object
 * @param x Specify the upper-left coordinate of the boundary rectangle
 * @param y Specify the upper-left coordinate of the boundary rectangle
 * @param x1 Calculated lower-right coordinate of the boundary rectangle
 * @param y1 Calculated lower-right coordinate of the boundary rectangle
 * @param w Calculated width of the boundary rectangle
 * @param h Calculated height of the boundary rectangle
 */

void AGUI::getTextBounds(const String& str, ACoord x, ACoord y,
                         ACoord* x1, ACoord* y1, ACoord* w, ACoord* h) {
    gfx->getTextBounds(str, (int16_t)x, (int16_t)y, (int16_t*)x1, (int16_t*)y1, (uint16_t*)w, (uint16_t*)h);
}  // getTextBounds()
